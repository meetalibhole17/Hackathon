{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "fd21b13d",
   "metadata": {},
   "source": [
    "## 1.Genetic Algorithms for Solving the Traveling Salesman Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "b5e1ec4a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generation 1: Best Fitness - 23\n",
      "Generation 2: Best Fitness - 32\n",
      "Generation 3: Best Fitness - 16\n",
      "Generation 4: Best Fitness - 24\n",
      "Generation 5: Best Fitness - 16\n",
      "Best Tour: ['B', 'D', 'C', 'A', 'E']\n",
      "Best Fitness: 16\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "# Number of cities in TSP\n",
    "V = 5\n",
    "\n",
    "# Names of the cities\n",
    "GENES = \"ABCDE\"\n",
    "\n",
    "# Structure of an individual\n",
    "class Individual:\n",
    "    def __init__(self, gnome=None):\n",
    "        if gnome is None:\n",
    "            self.gnome = random.sample(GENES, V)\n",
    "        else:\n",
    "            self.gnome = gnome\n",
    "        self.fitness = self.calculate_fitness()\n",
    "\n",
    "    def calculate_fitness(self):\n",
    "        total_distance = sum(\n",
    "            distance(self.gnome[i], self.gnome[i + 1])\n",
    "            for i in range(V - 1)\n",
    "            if distance(self.gnome[i], self.gnome[i + 1]) != float('inf')\n",
    "        )\n",
    "        if distance(self.gnome[-1], self.gnome[0]) != float('inf'):\n",
    "            total_distance += distance(self.gnome[-1], self.gnome[0])  # Return to the starting city\n",
    "        return total_distance\n",
    "\n",
    "# Function to calculate distance between two cities\n",
    "def distance(city1, city2):\n",
    "    #float('inf') represents positive infinity; indicating there is no direct edge in between those two cities it is used to indicate\n",
    "    #unbounded or undefined values and considering distances which are unreachable\n",
    "    distances = {\n",
    "        'A': [0, 2, float('inf'), 12, 5],\n",
    "        'B': [2, 0, 4, 8, float('inf')],\n",
    "        'C': [float('inf'), 4, 0, 3, 3],\n",
    "        'D': [12, 8, 3, 0, 10],\n",
    "        'E': [5, float('inf'), 3, 10, 0],\n",
    "    }\n",
    "    return distances[city1][GENES.index(city2)]\n",
    "\n",
    "# Genetic algorithm function\n",
    "def genetic_algorithm(population_size, num_generations):\n",
    "    population = [Individual() for _ in range(population_size)]\n",
    "\n",
    "    for generation in range(1, num_generations + 1):\n",
    "        population.sort(key=lambda x: x.fitness)\n",
    "\n",
    "        new_population = []\n",
    "\n",
    "        for _ in range(population_size // 2):\n",
    "            parent1, parent2 = random.sample(population[:population_size // 2], 2)\n",
    "            child_gnome = crossover(parent1.gnome, parent2.gnome)\n",
    "            new_population.extend([Individual(child_gnome)])\n",
    "\n",
    "        population = new_population\n",
    "\n",
    "        print(f\"Generation {generation}: Best Fitness - {population[0].fitness}\")\n",
    "\n",
    "    best_tour = population[0]\n",
    "    print(\"Best Tour:\", best_tour.gnome)\n",
    "    print(\"Best Fitness:\", best_tour.fitness)\n",
    "\n",
    "# Crossover function (Order Crossover)\n",
    "def crossover(parent1, parent2):\n",
    "    start, end = sorted(random.sample(range(V), 2))\n",
    "    child_gnome = [-1] * V\n",
    "\n",
    "    child_gnome[start:end + 1] = parent1[start:end + 1]\n",
    "\n",
    "    remaining_indices = [i for i in range(V) if parent2[i] not in child_gnome]\n",
    "    remaining_values = iter(parent2[i] for i in remaining_indices)\n",
    "\n",
    "    for i in range(V):\n",
    "        if child_gnome[i] == -1:\n",
    "            child_gnome[i] = next(remaining_values)\n",
    "\n",
    "    return child_gnome\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    POP_SIZE = 10\n",
    "    NUM_GENERATIONS = 5\n",
    "\n",
    "    genetic_algorithm(POP_SIZE, NUM_GENERATIONS)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f15689de",
   "metadata": {},
   "source": [
    "## 3.Use Local Search Algorithms for Solving the N-Queens Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "3050d315",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution:\n",
      ". . Q . . . . .\n",
      ". . . . Q . . .\n",
      ". Q . . . . . .\n",
      ". . . Q . . . .\n",
      "Q . . . . . . .\n",
      ". . Q . . . . .\n",
      ". . . . . . . Q\n",
      ". Q . . . . . .\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "def generate_random_board(n):\n",
    "    \"\"\" Generate a random board configuration \"\"\"\n",
    "    board = list(range(n))\n",
    "    random.shuffle(board)\n",
    "    return board\n",
    "\n",
    "def num_attacking_queens(board):\n",
    "    \"\"\" Calculate the number of pairs of attacking queens \"\"\"\n",
    "    n = len(board)\n",
    "    attacking_pairs = 0\n",
    "    for i in range(n):\n",
    "        for j in range(i + 1, n):\n",
    "            if abs(i - j) == abs(board[i] - board[j]):\n",
    "                attacking_pairs += 1\n",
    "    return attacking_pairs\n",
    "\n",
    "def get_next_board(board):\n",
    "    \"\"\" Generate next board by moving one queen to minimize attacks \"\"\"\n",
    "    n = len(board)\n",
    "    min_attacks = num_attacking_queens(board)\n",
    "    next_board = board[:]\n",
    "    \n",
    "    # Try moving each queen to minimize attacks\n",
    "    for i in range(n):\n",
    "        for j in range(n):\n",
    "            if j != board[i]:  # Try moving queen i to column j\n",
    "                new_board = board[:]\n",
    "                new_board[i] = j\n",
    "                num_attacks = num_attacking_queens(new_board)\n",
    "                if num_attacks < min_attacks:\n",
    "                    min_attacks = num_attacks\n",
    "                    next_board = new_board\n",
    "    \n",
    "    return next_board\n",
    "\n",
    "def hill_climbing(n):\n",
    "    \"\"\" Solve N-Queens problem using Hill Climbing \"\"\"\n",
    "    current_board = generate_random_board(n)\n",
    "    current_attacks = num_attacking_queens(current_board)\n",
    "    \n",
    "    while current_attacks > 0:\n",
    "        next_board = get_next_board(current_board)\n",
    "        next_attacks = num_attacking_queens(next_board)\n",
    "        \n",
    "        if next_attacks >= current_attacks:\n",
    "            break  # Stop if no better move\n",
    "        \n",
    "        current_board = next_board\n",
    "        current_attacks = next_attacks\n",
    "    \n",
    "    return current_board\n",
    "\n",
    "def print_board(board):\n",
    "    \"\"\" Print board configuration \"\"\"\n",
    "    n = len(board)\n",
    "    for row in range(n):\n",
    "        line = ['Q' if board[row] == col else '.' for col in range(n)]\n",
    "        print(' '.join(line))\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    n = 8  # Change this to desired board size\n",
    "    solution = hill_climbing(n)\n",
    "    print(\"Solution:\")\n",
    "    print_board(solution)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5c54483d",
   "metadata": {},
   "source": [
    "## 4.Depth-First Search for Solving the Tower of Hanoi Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0546c9f1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Move disk 1 from A to C\n",
      "Move disk 2 from A to B\n",
      "Move disk 1 from C to B\n",
      "Move disk 3 from A to C\n",
      "Move disk 1 from B to A\n",
      "Move disk 2 from B to C\n",
      "Move disk 1 from A to C\n",
      "Move disk 4 from A to B\n",
      "Move disk 1 from C to B\n",
      "Move disk 2 from C to A\n",
      "Move disk 1 from B to A\n",
      "Move disk 3 from C to B\n",
      "Move disk 1 from A to C\n",
      "Move disk 2 from A to B\n",
      "Move disk 1 from C to B\n",
      "Move disk 5 from A to C\n",
      "Move disk 1 from B to A\n",
      "Move disk 2 from B to C\n",
      "Move disk 1 from A to C\n",
      "Move disk 3 from B to A\n",
      "Move disk 1 from C to B\n",
      "Move disk 2 from C to A\n",
      "Move disk 1 from B to A\n",
      "Move disk 4 from B to C\n",
      "Move disk 1 from A to C\n",
      "Move disk 2 from A to B\n",
      "Move disk 1 from C to B\n",
      "Move disk 3 from A to C\n",
      "Move disk 1 from B to A\n",
      "Move disk 2 from B to C\n",
      "Move disk 1 from A to C\n"
     ]
    }
   ],
   "source": [
    "def tower_of_hanoi(n, source, target, auxiliary):\n",
    "    \"\"\" Solves the Tower of Hanoi problem using Depth-First Search (DFS) \"\"\"\n",
    "    if n == 1:\n",
    "        print(f\"Move disk 1 from {source} to {target}\")\n",
    "        return\n",
    "    \n",
    "    # Move n-1 disks from source to auxiliary using target as temporary\n",
    "    tower_of_hanoi(n - 1, source, auxiliary, target)\n",
    "    \n",
    "    # Move the nth disk from source to target\n",
    "    print(f\"Move disk {n} from {source} to {target}\")\n",
    "    \n",
    "    # Move n-1 disks from auxiliary to target using source as temporary\n",
    "    tower_of_hanoi(n - 1, auxiliary, target, source)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    n = 5  # Number of disks (change this to increase the number of disks)\n",
    "    tower_of_hanoi(n, 'A', 'C', 'B')  # 'A' is source, 'C' is target, 'B' is auxiliary"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f5dd371",
   "metadata": {},
   "source": [
    "## 5.Breadth-First Search for Solving the Tower of Hanoi Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "fe714706",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found with 6 moves:\n",
      "Move 1: B -> C\n",
      "Move 2: B -> A\n",
      "Move 3: C -> A\n",
      "Move 4: C -> B\n",
      "Move 5: A -> B\n",
      "Move 6: A -> C\n"
     ]
    }
   ],
   "source": [
    "from collections import deque\n",
    "\n",
    "class State:\n",
    "    def __init__(self, disks, source='A', target='C', auxiliary='B'):\n",
    "        self.disks = disks\n",
    "        self.source = source\n",
    "        self.target = target\n",
    "        self.auxiliary = auxiliary\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return self.disks == other.disks and \\\n",
    "               self.source == other.source and \\\n",
    "               self.target == other.target and \\\n",
    "               self.auxiliary == other.auxiliary\n",
    "\n",
    "    def __hash__(self):\n",
    "        return hash((self.disks, self.source, self.target, self.auxiliary))\n",
    "\n",
    "def get_next_states(state):\n",
    "    next_states = []\n",
    "    if state.disks > 0:\n",
    "        # Move the top disk from source to target\n",
    "        next_states.append(State(state.disks - 1, state.source, state.auxiliary, state.target))\n",
    "        next_states.append(State(state.disks, state.auxiliary, state.target, state.source))\n",
    "    return next_states\n",
    "\n",
    "def bfs_tower_of_hanoi(disks):\n",
    "    initial_state = State(disks)\n",
    "    target_state = State(0)  # All disks on target rod\n",
    "\n",
    "    queue = deque([(initial_state, [])])  # (current_state, path)\n",
    "    visited = set()\n",
    "    visited.add(initial_state)\n",
    "\n",
    "    while queue:\n",
    "        current_state, path = queue.popleft()\n",
    "\n",
    "        if current_state == target_state:\n",
    "            return path\n",
    "        \n",
    "        for next_state in get_next_states(current_state):\n",
    "            if next_state not in visited:\n",
    "                visited.add(next_state)\n",
    "                queue.append((next_state, path + [next_state]))\n",
    "\n",
    "    return None  # No solution found\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    disks = 3\n",
    "    solution_path = bfs_tower_of_hanoi(disks)\n",
    "    \n",
    "    if solution_path is not None:\n",
    "        print(f\"Solution found with {len(solution_path)} moves:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            print(f\"Move {i + 1}: {state.source} -> {state.target}\")\n",
    "    else:\n",
    "        print(\"No solution found for the Tower of Hanoi problem with the given number of disks.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2736997b",
   "metadata": {},
   "source": [
    "## 6.A* Search for Solving the Eight Puzzle Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "86ae4ece",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found in 1 steps.\n"
     ]
    }
   ],
   "source": [
    "import heapq\n",
    "from collections import deque\n",
    "\n",
    "# Define the goal state for the Eight Puzzle (1-8 representing tiles, 0 representing the empty space)\n",
    "goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n",
    "\n",
    "# Define the moves (left, right, up, down) represented as (column_delta, row_delta)\n",
    "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n",
    "\n",
    "def get_manhattan_distance(state):\n",
    "    \"\"\" Calculate the total Manhattan distance heuristic for the given state \"\"\"\n",
    "    distance = 0\n",
    "    for i in range(9):\n",
    "        if state[i] != 0:  # Ignore the empty space (represented by 0)\n",
    "            current_row, current_col = i // 3, i % 3\n",
    "            target_row, target_col = (state[i] - 1) // 3, (state[i] - 1) % 3\n",
    "            distance += abs(current_row - target_row) + abs(current_col - target_col)\n",
    "    return distance\n",
    "\n",
    "def is_valid_move(x, y):\n",
    "    \"\"\" Check if the move (x, y) is within the bounds of the 3x3 grid \"\"\"\n",
    "    return 0 <= x < 3 and 0 <= y < 3\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (column_delta, row_delta) to the state \"\"\"\n",
    "    empty_index = state.index(0)\n",
    "    empty_row, empty_col = empty_index // 3, empty_index % 3\n",
    "    new_col = empty_col + move[0]\n",
    "    new_row = empty_row + move[1]\n",
    "    new_index = new_row * 3 + new_col\n",
    "    new_state = list(state)\n",
    "    new_state[empty_index], new_state[new_index] = new_state[new_index], new_state[empty_index]\n",
    "    return tuple(new_state)\n",
    "\n",
    "def a_star_search(initial_state):\n",
    "    \"\"\" Solve the Eight Puzzle using A* search with Manhattan distance heuristic \"\"\"\n",
    "    priority_queue = []\n",
    "    heapq.heappush(priority_queue, (0 + get_manhattan_distance(initial_state), 0, initial_state))\n",
    "    visited = set()\n",
    "    visited.add(initial_state)\n",
    "    \n",
    "    while priority_queue:\n",
    "        _, cost, current_state = heapq.heappop(priority_queue)\n",
    "        \n",
    "        if current_state == goal_state:\n",
    "            return cost\n",
    "        \n",
    "        empty_index = current_state.index(0)\n",
    "        empty_row, empty_col = empty_index // 3, empty_index % 3\n",
    "        \n",
    "        for move in moves:\n",
    "            new_col = empty_col + move[0]\n",
    "            new_row = empty_row + move[1]\n",
    "            \n",
    "            if is_valid_move(new_col, new_row):\n",
    "                new_state = apply_move(current_state, move)\n",
    "                \n",
    "                if new_state not in visited:\n",
    "                    visited.add(new_state)\n",
    "                    new_cost = cost + 1\n",
    "                    priority = new_cost + get_manhattan_distance(new_state)\n",
    "                    heapq.heappush(priority_queue, (priority, new_cost, new_state))\n",
    "    \n",
    "    return -1  # No solution found\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Example initial state (customize with your own initial state)\n",
    "    initial_state = (1, 2, 3, 4, 5, 6, 7, 0, 8)  # Use 0 to represent the empty space\n",
    "    \n",
    "    # Solve the Eight Puzzle using A* search\n",
    "    steps = a_star_search(initial_state)\n",
    "    \n",
    "    if steps != -1:\n",
    "        print(f\"Solution found in {steps} steps.\")\n",
    "    else:\n",
    "        print(\"No solution found for the given initial state.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd209004",
   "metadata": {},
   "source": [
    "## 7.Iterative Deepening Depth-First Search for Solving the Eight Puzzle Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "f2854a9f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found in 1 steps:\n",
      "Step 0: (1, 2, 3, 4, 5, 6, 7, 0, 8)\n",
      "Step 1: (1, 2, 3, 4, 5, 6, 7, 8, 0)\n"
     ]
    }
   ],
   "source": [
    "# Define the goal state for the Eight Puzzle (1-8 representing tiles, 0 representing the empty space)\n",
    "goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n",
    "\n",
    "# Define the moves (left, right, up, down) represented as (column_delta, row_delta)\n",
    "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n",
    "\n",
    "def is_valid_move(x, y):\n",
    "    \"\"\" Check if the move (x, y) is within the bounds of the 3x3 grid \"\"\"\n",
    "    return 0 <= x < 3 and 0 <= y < 3\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (column_delta, row_delta) to the state \"\"\"\n",
    "    empty_index = state.index(0)\n",
    "    empty_row, empty_col = empty_index // 3, empty_index % 3\n",
    "    new_col = empty_col + move[0]\n",
    "    new_row = empty_row + move[1]\n",
    "    new_index = new_row * 3 + new_col\n",
    "    new_state = list(state)\n",
    "    new_state[empty_index], new_state[new_index] = new_state[new_index], new_state[empty_index]\n",
    "    return tuple(new_state)\n",
    "\n",
    "def depth_limited_dfs(current_state, depth_limit, path):\n",
    "    \"\"\" Perform depth-limited DFS up to a specified depth limit \"\"\"\n",
    "    if current_state == goal_state:\n",
    "        return path  # Return the path if the goal state is reached\n",
    "    \n",
    "    if depth_limit == 0:\n",
    "        return None  # Depth limit reached without finding the goal state\n",
    "    \n",
    "    empty_index = current_state.index(0)\n",
    "    empty_row, empty_col = empty_index // 3, empty_index % 3\n",
    "    \n",
    "    for move in moves:\n",
    "        new_col = empty_col + move[0]\n",
    "        new_row = empty_row + move[1]\n",
    "        \n",
    "        if is_valid_move(new_col, new_row):\n",
    "            new_state = apply_move(current_state, move)\n",
    "            \n",
    "            if new_state not in path:  # Avoid revisiting states to prevent cycles\n",
    "                result = depth_limited_dfs(new_state, depth_limit - 1, path + [new_state])\n",
    "                if result is not None:\n",
    "                    return result\n",
    "    \n",
    "    return None  # No solution found within the depth limit\n",
    "\n",
    "def iterative_deepening_dfs(initial_state):\n",
    "    \"\"\" Perform iterative deepening DFS to solve the Eight Puzzle \"\"\"\n",
    "    depth_limit = 0\n",
    "    while True:\n",
    "        result = depth_limited_dfs(initial_state, depth_limit, [initial_state])\n",
    "        if result is not None:\n",
    "            return result  # Solution found\n",
    "        depth_limit += 1  # Increase depth limit for the next iteration\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Example initial state (customize with your own initial state)\n",
    "    initial_state = (1, 2, 3, 4, 5, 6, 7, 0, 8)  # Use 0 to represent the empty space\n",
    "    \n",
    "    # Solve the Eight Puzzle using iterative deepening DFS\n",
    "    solution_path = iterative_deepening_dfs(initial_state)\n",
    "    \n",
    "    if solution_path is not None:\n",
    "        print(f\"Solution found in {len(solution_path) - 1} steps:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            print(f\"Step {i}: {state}\")\n",
    "    else:\n",
    "        print(\"No solution found for the given initial state within the search depth limit.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "285a5f5e",
   "metadata": {},
   "source": [
    "## 8.Uniform Cost Search for Solving the Eight Puzzle Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "31da9f1e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found in 1 steps:\n",
      "Step 0: (1, 2, 3, 4, 5, 6, 7, 0, 8)\n",
      "Step 1: (1, 2, 3, 4, 5, 6, 7, 8, 0)\n"
     ]
    }
   ],
   "source": [
    "import heapq\n",
    "\n",
    "# Define the goal state for the Eight Puzzle (1-8 representing tiles, 0 representing the empty space)\n",
    "goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n",
    "\n",
    "# Define the moves (left, right, up, down) represented as (column_delta, row_delta)\n",
    "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n",
    "\n",
    "def is_valid_move(x, y):\n",
    "    \"\"\" Check if the move (x, y) is within the bounds of the 3x3 grid \"\"\"\n",
    "    return 0 <= x < 3 and 0 <= y < 3\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (column_delta, row_delta) to the state \"\"\"\n",
    "    empty_index = state.index(0)\n",
    "    empty_row, empty_col = empty_index // 3, empty_index % 3\n",
    "    new_col = empty_col + move[0]\n",
    "    new_row = empty_row + move[1]\n",
    "    new_index = new_row * 3 + new_col\n",
    "    new_state = list(state)\n",
    "    new_state[empty_index], new_state[new_index] = new_state[new_index], new_state[empty_index]\n",
    "    return tuple(new_state)\n",
    "\n",
    "def calculate_path_cost(path):\n",
    "    \"\"\" Calculate the path cost (number of moves) \"\"\"\n",
    "    return len(path) - 1  # Subtract 1 to exclude the initial state\n",
    "\n",
    "def uniform_cost_search(initial_state):\n",
    "    \"\"\" Perform Uniform Cost Search to solve the Eight Puzzle \"\"\"\n",
    "    priority_queue = []\n",
    "    heapq.heappush(priority_queue, (0, [initial_state]))  # (path_cost, path)\n",
    "    explored = set()\n",
    "    \n",
    "    while priority_queue:\n",
    "        current_cost, current_path = heapq.heappop(priority_queue)\n",
    "        current_state = current_path[-1]\n",
    "        \n",
    "        if current_state == goal_state:\n",
    "            return current_path\n",
    "        \n",
    "        explored.add(current_state)\n",
    "        empty_index = current_state.index(0)\n",
    "        empty_row, empty_col = empty_index // 3, empty_index % 3\n",
    "        \n",
    "        for move in moves:\n",
    "            new_col = empty_col + move[0]\n",
    "            new_row = empty_row + move[1]\n",
    "            \n",
    "            if is_valid_move(new_col, new_row):\n",
    "                new_state = apply_move(current_state, move)\n",
    "                \n",
    "                if new_state not in explored:\n",
    "                    new_path = current_path + [new_state]\n",
    "                    new_cost = calculate_path_cost(new_path)\n",
    "                    heapq.heappush(priority_queue, (new_cost, new_path))\n",
    "    \n",
    "    return None  # No solution found\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Example initial state (customize with your own initial state)\n",
    "    initial_state = (1, 2, 3, 4, 5, 6, 7, 0, 8)  # Use 0 to represent the empty space\n",
    "    \n",
    "    # Solve the Eight Puzzle using Uniform Cost Search\n",
    "    solution_path = uniform_cost_search(initial_state)\n",
    "    \n",
    "    if solution_path is not None:\n",
    "        print(f\"Solution found in {calculate_path_cost(solution_path)} steps:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            print(f\"Step {i}: {state}\")\n",
    "    else:\n",
    "        print(\"No solution found for the given initial state.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d94b0a74",
   "metadata": {},
   "source": [
    "## 9.Heuristic Search Algorithms for Solving the Missionaries and Cannibals Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "1b298906",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found:\n",
      "Step 0: 2M-2C (right) <-> 1M-1C\n",
      "Step 1: 3M-2C (left) <-> 0M-1C\n",
      "Step 2: 3M-0C (right) <-> 0M-3C\n",
      "Step 3: 3M-1C (left) <-> 0M-2C\n",
      "Step 4: 1M-1C (right) <-> 2M-2C\n",
      "Step 5: 2M-2C (left) <-> 1M-1C\n",
      "Step 6: 0M-2C (right) <-> 3M-1C\n",
      "Step 7: 0M-3C (left) <-> 3M-0C\n",
      "Step 8: -1M-2C (right) <-> 4M-1C\n",
      "Step 9: 0M-2C (left) <-> 3M-1C\n",
      "Step 10: 0M-0C (right) <-> 3M-3C\n"
     ]
    }
   ],
   "source": [
    "import heapq\n",
    "\n",
    "# Define the goal state and initial state\n",
    "goal_state = (0, 0, 1)  # All missionaries and cannibals on the right bank\n",
    "initial_state = (3, 3, 0)  # All missionaries and cannibals on the left bank\n",
    "\n",
    "# Define moves (m, c) representing the number of missionaries and cannibals moved\n",
    "moves = [\n",
    "    (1, 0),  # Move one missionary from left to right\n",
    "    (2, 0),  # Move two missionaries from left to right\n",
    "    (0, 1),  # Move one cannibal from left to right\n",
    "    (0, 2),  # Move two cannibals from left to right\n",
    "    (1, 1)   # Move one missionary and one cannibal from left to right\n",
    "]\n",
    "\n",
    "def is_valid_state(state):\n",
    "    \"\"\" Check if a state is valid (no missionaries eaten by cannibals) \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    missionaries_right = 3 - missionaries_left\n",
    "    cannibals_right = 3 - cannibals_left\n",
    "    \n",
    "    # Check if missionaries are outnumbered by cannibals on either side\n",
    "    if missionaries_left > 0 and missionaries_left < cannibals_left:\n",
    "        return False\n",
    "    if missionaries_right > 0 and missionaries_right < cannibals_right:\n",
    "        return False\n",
    "    \n",
    "    return True\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (m, c) to a given state \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    m, c = move\n",
    "    \n",
    "    if boat_side == 0:\n",
    "        # Moving from left to right\n",
    "        new_state = (missionaries_left - m, cannibals_left - c, 1)\n",
    "    else:\n",
    "        # Moving from right to left\n",
    "        new_state = (missionaries_left + m, cannibals_left + c, 0)\n",
    "    \n",
    "    return new_state\n",
    "\n",
    "def heuristic(state):\n",
    "    \"\"\" Heuristic function: estimate the minimum number of moves to reach the goal \"\"\"\n",
    "    # Use the sum of missionaries and cannibals on the left bank as the heuristic estimate\n",
    "    missionaries_left, cannibals_left, _ = state\n",
    "    return missionaries_left + cannibals_left\n",
    "\n",
    "def a_star_search():\n",
    "    \"\"\" A* search to solve the Missionaries and Cannibals Problem \"\"\"\n",
    "    priority_queue = []\n",
    "    heapq.heappush(priority_queue, (heuristic(initial_state), initial_state, []))\n",
    "    visited = set()\n",
    "    \n",
    "    while priority_queue:\n",
    "        _, current_state, path = heapq.heappop(priority_queue)\n",
    "        \n",
    "        if current_state == goal_state:\n",
    "            return path\n",
    "        \n",
    "        if current_state not in visited:\n",
    "            visited.add(current_state)\n",
    "            missionaries_left, cannibals_left, boat_side = current_state\n",
    "            \n",
    "            for move in moves:\n",
    "                new_state = apply_move(current_state, move)\n",
    "                \n",
    "                if is_valid_state(new_state):\n",
    "                    new_path = path + [new_state]\n",
    "                    cost = len(new_path) + heuristic(new_state)\n",
    "                    heapq.heappush(priority_queue, (cost, new_state, new_path))\n",
    "    \n",
    "    return None  # No solution found\n",
    "\n",
    "def print_solution_path(solution_path):\n",
    "    \"\"\" Print the solution path \"\"\"\n",
    "    if solution_path is None:\n",
    "        print(\"No solution found.\")\n",
    "    else:\n",
    "        print(\"Solution found:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            missionaries_left, cannibals_left, boat_side = state\n",
    "            missionaries_right = 3 - missionaries_left\n",
    "            cannibals_right = 3 - cannibals_left\n",
    "            boat_location = \"left\" if boat_side == 0 else \"right\"\n",
    "            print(f\"Step {i}: {missionaries_left}M-{cannibals_left}C ({boat_location}) <-> {missionaries_right}M-{cannibals_right}C\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Solve the Missionaries and Cannibals Problem using A* search\n",
    "    solution_path = a_star_search()\n",
    "    print_solution_path(solution_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cc6952e3",
   "metadata": {},
   "source": [
    "## 10.Use Breadth-First Search (BFS) for solving the Missionaries and Cannibals problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "ca586cb1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found:\n",
      "Step 0: 3M-1C (right) <-> 0M-2C\n",
      "Step 1: 4M-1C (left) <-> -1M-2C\n",
      "Step 2: 3M-0C (right) <-> 0M-3C\n",
      "Step 3: 3M-1C (left) <-> 0M-2C\n",
      "Step 4: 1M-1C (right) <-> 2M-2C\n",
      "Step 5: 2M-2C (left) <-> 1M-1C\n",
      "Step 6: 0M-2C (right) <-> 3M-1C\n",
      "Step 7: 0M-3C (left) <-> 3M-0C\n",
      "Step 8: 0M-1C (right) <-> 3M-2C\n",
      "Step 9: 1M-1C (left) <-> 2M-2C\n",
      "Step 10: 0M-0C (right) <-> 3M-3C\n"
     ]
    }
   ],
   "source": [
    "from collections import deque\n",
    "\n",
    "# Define the goal state and initial state\n",
    "goal_state = (0, 0, 1)  # All missionaries and cannibals on the right bank\n",
    "initial_state = (3, 3, 0)  # All missionaries and cannibals on the left bank\n",
    "\n",
    "# Define moves (m, c) representing the number of missionaries and cannibals moved\n",
    "moves = [\n",
    "    (1, 0),  # Move one missionary from left to right\n",
    "    (2, 0),  # Move two missionaries from left to right\n",
    "    (0, 1),  # Move one cannibal from left to right\n",
    "    (0, 2),  # Move two cannibals from left to right\n",
    "    (1, 1)   # Move one missionary and one cannibal from left to right\n",
    "]\n",
    "\n",
    "def is_valid_state(state):\n",
    "    \"\"\" Check if a state is valid (no missionaries eaten by cannibals) \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    missionaries_right = 3 - missionaries_left\n",
    "    cannibals_right = 3 - cannibals_left\n",
    "    \n",
    "    # Check if missionaries are outnumbered by cannibals on either side\n",
    "    if missionaries_left > 0 and missionaries_left < cannibals_left:\n",
    "        return False\n",
    "    if missionaries_right > 0 and missionaries_right < cannibals_right:\n",
    "        return False\n",
    "    \n",
    "    return True\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (m, c) to a given state \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    m, c = move\n",
    "    \n",
    "    if boat_side == 0:\n",
    "        # Moving from left to right\n",
    "        new_state = (missionaries_left - m, cannibals_left - c, 1)\n",
    "    else:\n",
    "        # Moving from right to left\n",
    "        new_state = (missionaries_left + m, cannibals_left + c, 0)\n",
    "    \n",
    "    return new_state\n",
    "\n",
    "def bfs_search():\n",
    "    \"\"\" Breadth-First Search to solve the Missionaries and Cannibals Problem \"\"\"\n",
    "    queue = deque([(initial_state, [])])  # (current_state, path)\n",
    "    visited = set()\n",
    "    \n",
    "    while queue:\n",
    "        current_state, path = queue.popleft()\n",
    "        \n",
    "        if current_state == goal_state:\n",
    "            return path\n",
    "        \n",
    "        if current_state not in visited:\n",
    "            visited.add(current_state)\n",
    "            missionaries_left, cannibals_left, boat_side = current_state\n",
    "            \n",
    "            for move in moves:\n",
    "                new_state = apply_move(current_state, move)\n",
    "                \n",
    "                if is_valid_state(new_state):\n",
    "                    new_path = path + [new_state]\n",
    "                    queue.append((new_state, new_path))\n",
    "    \n",
    "    return None  # No solution found\n",
    "\n",
    "def print_solution_path(solution_path):\n",
    "    \"\"\" Print the solution path \"\"\"\n",
    "    if solution_path is None:\n",
    "        print(\"No solution found.\")\n",
    "    else:\n",
    "        print(\"Solution found:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            missionaries_left, cannibals_left, boat_side = state\n",
    "            missionaries_right = 3 - missionaries_left\n",
    "            cannibals_right = 3 - cannibals_left\n",
    "            boat_location = \"left\" if boat_side == 0 else \"right\"\n",
    "            print(f\"Step {i}: {missionaries_left}M-{cannibals_left}C ({boat_location}) <-> {missionaries_right}M-{cannibals_right}C\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Solve the Missionaries and Cannibals Problem using BFS\n",
    "    solution_path = bfs_search()\n",
    "    print_solution_path(solution_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0f237121",
   "metadata": {},
   "source": [
    "## 11.Use Depth-First Search (DFS) for solving the Missionaries and Cannibals problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "64605b41",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found:\n",
      "Step 1: Left: 3M 3C Boat: left Right: 0M 0C\n",
      "Step 2: Left: 2M 2C Boat: right Right: 1M 1C\n",
      "Step 3: Left: 3M 2C Boat: left Right: 0M 1C\n",
      "Step 4: Left: 3M 0C Boat: right Right: 0M 3C\n",
      "Step 5: Left: 3M 1C Boat: left Right: 0M 2C\n",
      "Step 6: Left: 1M 1C Boat: right Right: 2M 2C\n",
      "Step 7: Left: 2M 2C Boat: left Right: 1M 1C\n",
      "Step 8: Left: 0M 2C Boat: right Right: 3M 1C\n",
      "Step 9: Left: 0M 3C Boat: left Right: 3M 0C\n",
      "Step 10: Left: 0M 1C Boat: right Right: 3M 2C\n",
      "Step 11: Left: 0M 2C Boat: left Right: 3M 1C\n",
      "Step 12: Left: 0M 0C Boat: right Right: 3M 3C\n"
     ]
    }
   ],
   "source": [
    "class State:\n",
    "    def __init__(self, left_m, left_c, boat, right_m, right_c):\n",
    "        self.left_m = left_m\n",
    "        self.left_c = left_c\n",
    "        self.boat = boat\n",
    "        self.right_m = right_m\n",
    "        self.right_c = right_c\n",
    "\n",
    "    def is_valid(self):\n",
    "        # Check if the state is valid (no missionaries eaten)\n",
    "        return (self.left_m == 0 or self.left_m >= self.left_c) and \\\n",
    "               (self.right_m == 0 or self.right_m >= self.right_c)\n",
    "\n",
    "    def is_goal(self):\n",
    "        # Check if the state is the goal state\n",
    "        return self.left_m == 0 and self.left_c == 0\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"Left: {self.left_m}M {self.left_c}C Boat: {self.boat} Right: {self.right_m}M {self.right_c}C\"\n",
    "\n",
    "def move(state, m, c):\n",
    "    if state.boat == 'left':\n",
    "        return State(state.left_m - m, state.left_c - c, 'right', state.right_m + m, state.right_c + c)\n",
    "    else:\n",
    "        return State(state.left_m + m, state.left_c + c, 'left', state.right_m - m, state.right_c - c)\n",
    "\n",
    "def dfs(current_state, visited_states, path):\n",
    "    if current_state.is_goal():\n",
    "        path.append(current_state)\n",
    "        return True\n",
    "\n",
    "    visited_states.add(str(current_state))\n",
    "\n",
    "    for m, c in [(0, 1), (1, 0), (1, 1), (2, 0), (0, 2)]:\n",
    "        next_state = move(current_state, m, c)\n",
    "\n",
    "        if next_state.is_valid() and str(next_state) not in visited_states:\n",
    "            path.append(current_state)\n",
    "            if dfs(next_state, visited_states, path):\n",
    "                return True\n",
    "            path.pop()\n",
    "\n",
    "    return False\n",
    "\n",
    "def solve():\n",
    "    initial_state = State(3, 3, 'left', 0, 0)\n",
    "    visited_states = set()\n",
    "    path = []\n",
    "\n",
    "    if dfs(initial_state, visited_states, path):\n",
    "        print(\"Solution found:\")\n",
    "        for step, state in enumerate(path):\n",
    "            print(f\"Step {step + 1}: {state}\")\n",
    "    else:\n",
    "        print(\"No solution found.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    solve()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b03f35a6",
   "metadata": {},
   "source": [
    "## 12.Use Iterative Deepening Depth-First Search (IDDFS)for solving the Missionaries and Cannibals problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "0f2c914f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found:\n",
      "Step 0: 3M-3C (left) <-> 0M-0C\n",
      "Step 1: 3M-1C (right) <-> 0M-2C\n",
      "Step 2: 4M-1C (left) <-> -1M-2C\n",
      "Step 3: 3M-0C (right) <-> 0M-3C\n",
      "Step 4: 3M-1C (left) <-> 0M-2C\n",
      "Step 5: 1M-1C (right) <-> 2M-2C\n",
      "Step 6: 2M-2C (left) <-> 1M-1C\n",
      "Step 7: 0M-2C (right) <-> 3M-1C\n",
      "Step 8: 0M-3C (left) <-> 3M-0C\n",
      "Step 9: 0M-1C (right) <-> 3M-2C\n",
      "Step 10: 1M-1C (left) <-> 2M-2C\n",
      "Step 11: 0M-0C (right) <-> 3M-3C\n"
     ]
    }
   ],
   "source": [
    "# Define the goal state and initial state\n",
    "goal_state = (0, 0, 1)  # All missionaries and cannibals on the right bank\n",
    "initial_state = (3, 3, 0)  # All missionaries and cannibals on the left bank\n",
    "\n",
    "# Define moves (m, c) representing the number of missionaries and cannibals moved\n",
    "moves = [\n",
    "    (1, 0),  # Move one missionary from left to right\n",
    "    (2, 0),  # Move two missionaries from left to right\n",
    "    (0, 1),  # Move one cannibal from left to right\n",
    "    (0, 2),  # Move two cannibals from left to right\n",
    "    (1, 1)   # Move one missionary and one cannibal from left to right\n",
    "]\n",
    "\n",
    "def is_valid_state(state):\n",
    "    \"\"\" Check if a state is valid (no missionaries eaten by cannibals) \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    missionaries_right = 3 - missionaries_left\n",
    "    cannibals_right = 3 - cannibals_left\n",
    "    \n",
    "    # Check if missionaries are outnumbered by cannibals on either side\n",
    "    if missionaries_left > 0 and missionaries_left < cannibals_left:\n",
    "        return False\n",
    "    if missionaries_right > 0 and missionaries_right < cannibals_right:\n",
    "        return False\n",
    "    \n",
    "    return True\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (m, c) to a given state \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    m, c = move\n",
    "    \n",
    "    if boat_side == 0:\n",
    "        # Moving from left to right\n",
    "        new_state = (missionaries_left - m, cannibals_left - c, 1)\n",
    "    else:\n",
    "        # Moving from right to left\n",
    "        new_state = (missionaries_left + m, cannibals_left + c, 0)\n",
    "    \n",
    "    return new_state\n",
    "\n",
    "def dls_search(current_state, path, depth_limit):\n",
    "    \"\"\" Depth-Limited Search (DLS) for a specific depth limit \"\"\"\n",
    "    if depth_limit == 0 and current_state != goal_state:\n",
    "        return None\n",
    "    \n",
    "    if current_state == goal_state:\n",
    "        return path\n",
    "    \n",
    "    missionaries_left, cannibals_left, boat_side = current_state\n",
    "    \n",
    "    for move in moves:\n",
    "        new_state = apply_move(current_state, move)\n",
    "        \n",
    "        if is_valid_state(new_state):\n",
    "            new_path = path + [new_state]\n",
    "            result = dls_search(new_state, new_path, depth_limit - 1)\n",
    "            if result is not None:\n",
    "                return result\n",
    "    \n",
    "    return None\n",
    "\n",
    "def iddfs_search():\n",
    "    \"\"\" Iterative Deepening Depth-First Search (IDDFS) to solve the Missionaries and Cannibals Problem \"\"\"\n",
    "    depth_limit = 0\n",
    "    \n",
    "    while True:\n",
    "        initial_path = [(initial_state)]\n",
    "        result = dls_search(initial_state, initial_path, depth_limit)\n",
    "        if result is not None:\n",
    "            return result\n",
    "        depth_limit += 1\n",
    "\n",
    "def print_solution_path(solution_path):\n",
    "    \"\"\" Print the solution path \"\"\"\n",
    "    if solution_path is None:\n",
    "        print(\"No solution found.\")\n",
    "    else:\n",
    "        print(\"Solution found:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            missionaries_left, cannibals_left, boat_side = state\n",
    "            missionaries_right = 3 - missionaries_left\n",
    "            cannibals_right = 3 - cannibals_left\n",
    "            boat_location = \"left\" if boat_side == 0 else \"right\"\n",
    "            print(f\"Step {i}: {missionaries_left}M-{cannibals_left}C ({boat_location}) <-> {missionaries_right}M-{cannibals_right}C\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Solve the Missionaries and Cannibals Problem using IDDFS\n",
    "    solution_path = iddfs_search()\n",
    "    print_solution_path(solution_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c76dffd",
   "metadata": {},
   "source": [
    "## 13.Use Uniform Cost Search (UCS)for solving the Missionaries and Cannibals problem: Brignt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "0c02d431",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found:\n",
      "Step 0: 3M-3C (left) <-> 0M-0C\n",
      "Step 1: 2M-2C (right) <-> 1M-1C\n",
      "Step 2: 3M-2C (left) <-> 0M-1C\n",
      "Step 3: 3M-0C (right) <-> 0M-3C\n",
      "Step 4: 3M-1C (left) <-> 0M-2C\n",
      "Step 5: 1M-1C (right) <-> 2M-2C\n",
      "Step 6: 2M-2C (left) <-> 1M-1C\n",
      "Step 7: 0M-2C (right) <-> 3M-1C\n",
      "Step 8: 0M-3C (left) <-> 3M-0C\n",
      "Step 9: -1M-2C (right) <-> 4M-1C\n",
      "Step 10: 0M-2C (left) <-> 3M-1C\n",
      "Step 11: 0M-0C (right) <-> 3M-3C\n"
     ]
    }
   ],
   "source": [
    "import heapq\n",
    "\n",
    "# Define the goal state and initial state\n",
    "goal_state = (0, 0, 1)  # All missionaries and cannibals on the right bank\n",
    "initial_state = (3, 3, 0)  # All missionaries and cannibals on the left bank\n",
    "\n",
    "# Define moves (m, c) representing the number of missionaries and cannibals moved\n",
    "moves = [\n",
    "    (1, 0),  # Move one missionary from left to right\n",
    "    (2, 0),  # Move two missionaries from left to right\n",
    "    (0, 1),  # Move one cannibal from left to right\n",
    "    (0, 2),  # Move two cannibals from left to right\n",
    "    (1, 1)   # Move one missionary and one cannibal from left to right\n",
    "]\n",
    "\n",
    "def is_valid_state(state):\n",
    "    \"\"\" Check if a state is valid (no missionaries eaten by cannibals) \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    missionaries_right = 3 - missionaries_left\n",
    "    cannibals_right = 3 - cannibals_left\n",
    "    \n",
    "    # Check if missionaries are outnumbered by cannibals on either side\n",
    "    if missionaries_left > 0 and missionaries_left < cannibals_left:\n",
    "        return False\n",
    "    if missionaries_right > 0 and missionaries_right < cannibals_right:\n",
    "        return False\n",
    "    \n",
    "    return True\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (m, c) to a given state \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    m, c = move\n",
    "    \n",
    "    if boat_side == 0:\n",
    "        # Moving from left to right\n",
    "        new_state = (missionaries_left - m, cannibals_left - c, 1)\n",
    "    else:\n",
    "        # Moving from right to left\n",
    "        new_state = (missionaries_left + m, cannibals_left + c, 0)\n",
    "    \n",
    "    return new_state\n",
    "\n",
    "def ucs_search():\n",
    "    \"\"\" Uniform Cost Search (UCS) to solve the Missionaries and Cannibals Problem \"\"\"\n",
    "    priority_queue = []\n",
    "    heapq.heappush(priority_queue, (0, [initial_state]))  # (cost, path)\n",
    "    visited = set()\n",
    "    \n",
    "    while priority_queue:\n",
    "        current_cost, current_path = heapq.heappop(priority_queue)\n",
    "        current_state = current_path[-1]\n",
    "        \n",
    "        if current_state == goal_state:\n",
    "            return current_path\n",
    "        \n",
    "        if current_state not in visited:\n",
    "            visited.add(current_state)\n",
    "            missionaries_left, cannibals_left, boat_side = current_state\n",
    "            \n",
    "            for move in moves:\n",
    "                new_state = apply_move(current_state, move)\n",
    "                \n",
    "                if is_valid_state(new_state):\n",
    "                    new_cost = current_cost + 1  # Uniform cost search (each move cost = 1)\n",
    "                    new_path = current_path + [new_state]\n",
    "                    heapq.heappush(priority_queue, (new_cost, new_path))\n",
    "    \n",
    "    return None  # No solution found\n",
    "\n",
    "def print_solution_path(solution_path):\n",
    "    \"\"\" Print the solution path \"\"\"\n",
    "    if solution_path is None:\n",
    "        print(\"No solution found.\")\n",
    "    else:\n",
    "        print(\"Solution found:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            missionaries_left, cannibals_left, boat_side = state\n",
    "            missionaries_right = 3 - missionaries_left\n",
    "            cannibals_right = 3 - cannibals_left\n",
    "            boat_location = \"left\" if boat_side == 0 else \"right\"\n",
    "            print(f\"Step {i}: {missionaries_left}M-{cannibals_left}C ({boat_location}) <-> {missionaries_right}M-{cannibals_right}C\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Solve the Missionaries and Cannibals Problem using Uniform Cost Search (UCS)\n",
    "    solution_path = ucs_search()\n",
    "    print_solution_path(solution_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "069849ab",
   "metadata": {},
   "source": [
    "## 14.Use Greedy Best-First Search for solving the Missionaries and Cannibals problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "b29419c5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "No solution found.\n"
     ]
    }
   ],
   "source": [
    "import heapq\n",
    "\n",
    "# Define the goal state\n",
    "goal_state = (0, 0)\n",
    "\n",
    "# Define the initial state\n",
    "initial_state = (3, 3)\n",
    "\n",
    "# Define the heuristic function\n",
    "def heuristic(state):\n",
    "    return state[0] + state[1]\n",
    "\n",
    "# Define a function to check if a state is valid\n",
    "def is_valid(state):\n",
    "    missionaries, cannibals = state\n",
    "    if missionaries < 0 or missionaries > 3 or cannibals < 0 or cannibals > 3:\n",
    "        return False\n",
    "    if missionaries < cannibals and missionaries > 0:\n",
    "        return False\n",
    "    if 3 - missionaries < 3 - cannibals and missionaries < 3:\n",
    "        return False\n",
    "    return True\n",
    "\n",
    "# Define a function to find the possible moves from a given state\n",
    "def find_moves(state):\n",
    "    moves = []\n",
    "    for i in range(3):\n",
    "        for j in range(3):\n",
    "            if i + j > 0 and i + j <= 2:\n",
    "                moves.append((i, j))\n",
    "    return moves\n",
    "\n",
    "# Define a function to apply a move to a state\n",
    "def apply_move(state, move):\n",
    "    missionaries, cannibals = state\n",
    "    move_m, move_c = move\n",
    "    if state == initial_state:  # Check the side of the boat\n",
    "        new_state = (missionaries - move_m, cannibals - move_c)\n",
    "    else:\n",
    "        new_state = (missionaries + move_m, cannibals + move_c)\n",
    "    return new_state\n",
    "\n",
    "# Greedy Best-First Search algorithm\n",
    "def greedy_best_first_search():\n",
    "    frontier = [(heuristic(initial_state), initial_state, [])]  # Priority queue sorted by heuristic value\n",
    "    explored = set()  # Set to keep track of explored states\n",
    "\n",
    "    while frontier:\n",
    "        _, current_state, path = heapq.heappop(frontier)\n",
    "        if current_state == goal_state:\n",
    "            return path\n",
    "\n",
    "        explored.add(current_state)\n",
    "\n",
    "        for move in find_moves(current_state):\n",
    "            new_state = apply_move(current_state, move)\n",
    "            if new_state not in explored and is_valid(new_state):\n",
    "                heapq.heappush(frontier, (heuristic(new_state), new_state, path + [move]))\n",
    "\n",
    "    return None  # No solution found\n",
    "\n",
    "# Example usage\n",
    "if __name__ == \"__main__\":\n",
    "    solution = greedy_best_first_search()\n",
    "    if solution:\n",
    "        print(\"Moves to solve the Missionaries and Cannibals problem:\")\n",
    "        for i, move in enumerate(solution):\n",
    "            print(\"Step\", i + 1, \": Move\", move)\n",
    "    else:\n",
    "        print(\"No solution found.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "222e5a66",
   "metadata": {},
   "source": [
    "## 15.Use A* Search for solving the Missionaries and Cannibals problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "5ef7bc4c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Solution found:\n",
      "Step 0: 3M-3C (left) <-> 0M-0C\n",
      "Step 1: 2M-2C (right) <-> 1M-1C\n",
      "Step 2: 3M-2C (left) <-> 0M-1C\n",
      "Step 3: 3M-0C (right) <-> 0M-3C\n",
      "Step 4: 3M-1C (left) <-> 0M-2C\n",
      "Step 5: 1M-1C (right) <-> 2M-2C\n",
      "Step 6: 2M-2C (left) <-> 1M-1C\n",
      "Step 7: 0M-2C (right) <-> 3M-1C\n",
      "Step 8: 0M-3C (left) <-> 3M-0C\n",
      "Step 9: -1M-2C (right) <-> 4M-1C\n",
      "Step 10: 0M-2C (left) <-> 3M-1C\n",
      "Step 11: 0M-0C (right) <-> 3M-3C\n"
     ]
    }
   ],
   "source": [
    "import heapq\n",
    "\n",
    "# Define the goal state and initial state\n",
    "goal_state = (0, 0, 1)  # All missionaries and cannibals on the right bank\n",
    "initial_state = (3, 3, 0)  # All missionaries and cannibals on the left bank\n",
    "\n",
    "# Define moves (m, c) representing the number of missionaries and cannibals moved\n",
    "moves = [\n",
    "    (1, 0),  # Move one missionary from left to right\n",
    "    (2, 0),  # Move two missionaries from left to right\n",
    "    (0, 1),  # Move one cannibal from left to right\n",
    "    (0, 2),  # Move two cannibals from left to right\n",
    "    (1, 1)   # Move one missionary and one cannibal from left to right\n",
    "]\n",
    "\n",
    "def is_valid_state(state):\n",
    "    \"\"\" Check if a state is valid (no missionaries eaten by cannibals) \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    missionaries_right = 3 - missionaries_left\n",
    "    cannibals_right = 3 - cannibals_left\n",
    "    \n",
    "    # Check if missionaries are outnumbered by cannibals on either side\n",
    "    if missionaries_left > 0 and missionaries_left < cannibals_left:\n",
    "        return False\n",
    "    if missionaries_right > 0 and missionaries_right < cannibals_right:\n",
    "        return False\n",
    "    \n",
    "    return True\n",
    "\n",
    "def apply_move(state, move):\n",
    "    \"\"\" Apply a move (m, c) to a given state \"\"\"\n",
    "    missionaries_left, cannibals_left, boat_side = state\n",
    "    m, c = move\n",
    "    \n",
    "    if boat_side == 0:\n",
    "        # Moving from left to right\n",
    "        new_state = (missionaries_left - m, cannibals_left - c, 1)\n",
    "    else:\n",
    "        # Moving from right to left\n",
    "        new_state = (missionaries_left + m, cannibals_left + c, 0)\n",
    "    \n",
    "    return new_state\n",
    "\n",
    "def a_star_search():\n",
    "    \"\"\" A* Search using a heuristic to solve the Missionaries and Cannibals Problem \"\"\"\n",
    "    priority_queue = []\n",
    "    initial_heuristic = heuristic(initial_state)\n",
    "    heapq.heappush(priority_queue, (initial_heuristic, [initial_state]))  # (heuristic_value, path)\n",
    "    visited = set()\n",
    "    cost_so_far = {initial_state: 0}\n",
    "    \n",
    "    while priority_queue:\n",
    "        _, current_path = heapq.heappop(priority_queue)\n",
    "        current_state = current_path[-1]\n",
    "        \n",
    "        if current_state == goal_state:\n",
    "            return current_path\n",
    "        \n",
    "        if current_state not in visited:\n",
    "            visited.add(current_state)\n",
    "            missionaries_left, cannibals_left, boat_side = current_state\n",
    "            \n",
    "            for move in moves:\n",
    "                new_state = apply_move(current_state, move)\n",
    "                \n",
    "                if is_valid_state(new_state):\n",
    "                    new_path = current_path + [new_state]\n",
    "                    new_cost = cost_so_far[current_state] + 1  # Assuming uniform cost per move\n",
    "                    \n",
    "                    if new_state not in cost_so_far or new_cost < cost_so_far[new_state]:\n",
    "                        cost_so_far[new_state] = new_cost\n",
    "                        priority = new_cost + heuristic(new_state)\n",
    "                        heapq.heappush(priority_queue, (priority, new_path))\n",
    "    \n",
    "    return None  # No solution found\n",
    "\n",
    "def heuristic(state):\n",
    "    \"\"\" Heuristic function for the Missionaries and Cannibals Problem \"\"\"\n",
    "    missionaries_left, cannibals_left, _ = state\n",
    "    return missionaries_left + cannibals_left  # Heuristic: sum of missionaries and cannibals on the left bank\n",
    "\n",
    "def print_solution_path(solution_path):\n",
    "    \"\"\" Print the solution path \"\"\"\n",
    "    if solution_path is None:\n",
    "        print(\"No solution found.\")\n",
    "    else:\n",
    "        print(\"Solution found:\")\n",
    "        for i, state in enumerate(solution_path):\n",
    "            missionaries_left, cannibals_left, boat_side = state\n",
    "            missionaries_right = 3 - missionaries_left\n",
    "            cannibals_right = 3 - cannibals_left\n",
    "            boat_location = \"left\" if boat_side == 0 else \"right\"\n",
    "            print(f\"Step {i}: {missionaries_left}M-{cannibals_left}C ({boat_location}) <-> {missionaries_right}M-{cannibals_right}C\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Solve the Missionaries and Cannibals Problem using A* Search\n",
    "    solution_path = a_star_search()\n",
    "    print_solution_path(solution_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f99223ad",
   "metadata": {},
   "source": [
    "## 16.Water Jug Problem solving by using production system approach"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "afbd78d2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Steps to measure 2 liters using jugs 4 and 3:\n",
      "Step 1: Fill Jug B\n",
      "Step 2: Pour B to A\n",
      "Step 3: Fill Jug B\n",
      "Step 4: Pour B to A\n"
     ]
    }
   ],
   "source": [
    "def water_jug_problem_with_steps(jug_a_capacity, jug_b_capacity, target_volume):\n",
    "    \"\"\" Solve the Water Jug Problem and display the steps using a production system approach \"\"\"\n",
    "    initial_state = (0, 0)  # Start with both jugs empty\n",
    "    visited = set()  # To track visited states\n",
    "    state_queue = [(initial_state, [])]  # Queue of (state, steps) tuples\n",
    "\n",
    "    # Production rules for filling, emptying, and pouring water between jugs\n",
    "    production_rules = [\n",
    "        (\"Fill Jug A\", lambda x, y: (jug_a_capacity, y)),  # Fill Jug A\n",
    "        (\"Fill Jug B\", lambda x, y: (x, jug_b_capacity)),  # Fill Jug B\n",
    "        (\"Empty Jug A\", lambda x, y: (0, y)),  # Empty Jug A\n",
    "        (\"Empty Jug B\", lambda x, y: (x, 0)),  # Empty Jug B\n",
    "        (\"Pour B to A\", lambda x, y: (min(x + y, jug_a_capacity), max(0, x + y - jug_a_capacity))),  # Pour from B to A\n",
    "        (\"Pour A to B\", lambda x, y: (max(0, x + y - jug_b_capacity), min(x + y, jug_b_capacity)))   # Pour from A to B\n",
    "    ]\n",
    "\n",
    "    # Explore states using a breadth-first search approach\n",
    "    while state_queue:\n",
    "        current_state, steps = state_queue.pop(0)  # Get the first (state, steps) tuple from the queue\n",
    "\n",
    "        if current_state in visited:\n",
    "            continue  # Skip visited states\n",
    "\n",
    "        visited.add(current_state)  # Mark current state as visited\n",
    "\n",
    "        # Check if the goal state is reached\n",
    "        if current_state[0] == target_volume or current_state[1] == target_volume:\n",
    "            return steps  # Return the sequence of steps (actions)\n",
    "\n",
    "        # Apply each production rule to generate new states\n",
    "        for action_name, rule in production_rules:\n",
    "            new_state = rule(current_state[0], current_state[1])\n",
    "\n",
    "            if new_state not in visited:\n",
    "                new_steps = steps + [action_name]  # Append the current action to the sequence of steps\n",
    "                state_queue.append((new_state, new_steps))  # Add new (state, steps) tuple to the queue\n",
    "\n",
    "    return None  # No solution found\n",
    "\n",
    "# Example usage:\n",
    "jug_a_capacity = 4\n",
    "jug_b_capacity = 3\n",
    "target_volume = 2\n",
    "\n",
    "steps = water_jug_problem_with_steps(jug_a_capacity, jug_b_capacity, target_volume)\n",
    "if steps:\n",
    "    print(f\"Steps to measure {target_volume} liters using jugs {jug_a_capacity} and {jug_b_capacity}:\")\n",
    "    for i, step in enumerate(steps, 1):\n",
    "        print(f\"Step {i}: {step}\")\n",
    "else:\n",
    "    print(f\"Target volume of {target_volume} liters cannot be measured using the given jugs.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a748048",
   "metadata": {},
   "source": [
    "## 17.Tic Tac Toe game implementation by Magic Square Method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "8d9c0894",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Welcome to Tic-Tac-Toe using Magic Square technique!\n",
      "  |   |  \n",
      "-------------\n",
      "  |   |  \n",
      "-------------\n",
      "  |   |  \n",
      "-------------\n",
      "Enter your move (1-9): 4\n",
      "  |   |  \n",
      "-------------\n",
      "X |   |  \n",
      "-------------\n",
      "  |   |  \n",
      "-------------\n",
      "Computer chooses position 5\n",
      "  |   |  \n",
      "-------------\n",
      "X | O |  \n",
      "-------------\n",
      "  |   |  \n",
      "-------------\n",
      "Enter your move (1-9): 1\n",
      "X |   |  \n",
      "-------------\n",
      "X | O |  \n",
      "-------------\n",
      "  |   |  \n",
      "-------------\n",
      "Computer chooses position 7\n",
      "X |   |  \n",
      "-------------\n",
      "X | O |  \n",
      "-------------\n",
      "O |   |  \n",
      "-------------\n",
      "Enter your move (1-9): 3\n",
      "X |   | X\n",
      "-------------\n",
      "X | O |  \n",
      "-------------\n",
      "O |   |  \n",
      "-------------\n",
      "Computer chooses position 2\n",
      "X | O | X\n",
      "-------------\n",
      "X | O |  \n",
      "-------------\n",
      "O |   |  \n",
      "-------------\n",
      "Enter your move (1-9): 8\n",
      "X | O | X\n",
      "-------------\n",
      "X | O |  \n",
      "-------------\n",
      "O | X |  \n",
      "-------------\n",
      "Computer chooses position 6\n",
      "X | O | X\n",
      "-------------\n",
      "X | O | O\n",
      "-------------\n",
      "O | X |  \n",
      "-------------\n",
      "Enter your move (1-9): 9\n",
      "X | O | X\n",
      "-------------\n",
      "X | O | O\n",
      "-------------\n",
      "O | X | X\n",
      "-------------\n",
      "It's a tie!\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "def print_board(board):\n",
    "    for row in board:\n",
    "        print(\" | \".join(row))\n",
    "        print(\"-\" * 13)\n",
    "\n",
    "def is_winner(board, player):\n",
    "    for row in board:\n",
    "        if all(cell == player for cell in row):\n",
    "            return True\n",
    "\n",
    "    for col in range(3):\n",
    "        if all(board[row][col] == player for row in range(3)):\n",
    "            return True\n",
    "\n",
    "    if all(board[i][i] == player for i in range(3)) or all(board[i][2 - i] == player for i in range(3)):\n",
    "        return True\n",
    "\n",
    "    return False\n",
    "\n",
    "def is_board_full(board):\n",
    "    return all(cell != ' ' for row in board for cell in row)\n",
    "\n",
    "def get_user_move():\n",
    "    while True:\n",
    "        try:\n",
    "            move = int(input(\"Enter your move (1-9): \"))\n",
    "            if 1 <= move <= 9:\n",
    "                return move\n",
    "            else:\n",
    "                print(\"Invalid move. Please enter a number between 1 and 9.\")\n",
    "        except ValueError:\n",
    "            print(\"Invalid input. Please enter a number.\")\n",
    "\n",
    "def calculate_computer_move(board, player_symbol, computer_symbol):\n",
    "    magic_square = [\n",
    "        [8, 3, 4],\n",
    "        [1, 5, 9],\n",
    "        [6, 7, 2]\n",
    "    ]\n",
    "\n",
    "    empty_cells = [(i, j) for i in range(3) for j in range(3) if board[i][j] == ' ']\n",
    "\n",
    "    for i, j in empty_cells:\n",
    "        temp_board = [row[:] for row in board]\n",
    "        temp_board[i][j] = computer_symbol\n",
    "        if is_winner(temp_board, computer_symbol):\n",
    "            return i * 3 + j + 1\n",
    "\n",
    "    for i, j in empty_cells:\n",
    "        temp_board = [row[:] for row in board]\n",
    "        temp_board[i][j] = player_symbol\n",
    "        if is_winner(temp_board, player_symbol):\n",
    "            return i * 3 + j + 1\n",
    "\n",
    "    return random.choice(empty_cells)[0] * 3 + random.choice(empty_cells)[1] + 1\n",
    "\n",
    "def play_tic_tac_toe():\n",
    "    board = [[' ' for _ in range(3)] for _ in range(3)]\n",
    "    user_symbol, computer_symbol = 'X', 'O'\n",
    "    print(\"Welcome to Tic-Tac-Toe using Magic Square technique!\")\n",
    "    print_board(board)\n",
    "\n",
    "    for move_num in range(1, 10):\n",
    "        current_player = user_symbol if move_num % 2 == 1 else computer_symbol\n",
    "\n",
    "        if current_player == user_symbol:\n",
    "            user_move = get_user_move()\n",
    "            row, col = divmod(user_move - 1, 3)\n",
    "        else:\n",
    "            computer_move = calculate_computer_move(board, user_symbol, computer_symbol)\n",
    "            row, col = divmod(computer_move - 1, 3)\n",
    "            print(f\"Computer chooses position {computer_move}\")\n",
    "\n",
    "        while board[row][col] != ' ':\n",
    "            print(\"ERROR! That position is already taken. Choose a different one.\")\n",
    "            if current_player == user_symbol:\n",
    "                user_move = get_user_move()\n",
    "                row, col = divmod(user_move - 1, 3)\n",
    "            else:\n",
    "                computer_move = calculate_computer_move(board, user_symbol, computer_symbol)\n",
    "                row, col = divmod(computer_move - 1, 3)\n",
    "\n",
    "        board[row][col] = user_symbol if current_player == user_symbol else computer_symbol\n",
    "        print_board(board)\n",
    "\n",
    "        if is_winner(board, current_player):\n",
    "            print(f\"{current_player} wins!\")\n",
    "            break\n",
    "\n",
    "        if is_board_full(board):\n",
    "            print(\"It's a tie!\")\n",
    "            break\n",
    "\n",
    "\n",
    "play_tic_tac_toe()       "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f7e077e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0|0|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "Player 1's turn\n",
      "Enter row (1-3): 1\n",
      "Enter column (1-3): 2\n",
      "0|1|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "Player 2's turn\n",
      "Enter row (1-3): 2\n",
      "Enter column (1-3): 2\n",
      "0|1|0\n",
      "-----\n",
      "0|2|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "Player 1's turn\n",
      "Enter row (1-3): 1\n",
      "Enter column (1-3): 3\n",
      "0|1|1\n",
      "-----\n",
      "0|2|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "Player 2's turn\n",
      "Enter row (1-3): 1\n",
      "Enter column (1-3): 1\n",
      "2|1|1\n",
      "-----\n",
      "0|2|0\n",
      "-----\n",
      "0|0|0\n",
      "-----\n",
      "Player 1's turn\n",
      "Enter row (1-3): 3\n",
      "Enter column (1-3): 3\n",
      "2|1|1\n",
      "-----\n",
      "0|2|0\n",
      "-----\n",
      "0|0|1\n",
      "-----\n",
      "Player 2's turn\n",
      "Enter row (1-3): 2\n",
      "Enter column (1-3): 3\n",
      "2|1|1\n",
      "-----\n",
      "0|2|2\n",
      "-----\n",
      "0|0|1\n",
      "-----\n",
      "Player 1's turn\n",
      "Enter row (1-3): 2\n",
      "Enter column (1-3): 1\n",
      "2|1|1\n",
      "-----\n",
      "1|2|2\n",
      "-----\n",
      "0|0|1\n",
      "-----\n",
      "Player 2's turn\n",
      "Enter row (1-3): 3\n",
      "Enter column (1-3): 2\n",
      "2|1|1\n",
      "-----\n",
      "1|2|2\n",
      "-----\n",
      "0|2|1\n",
      "-----\n",
      "Player 1's turn\n",
      "Enter row (1-3): 3\n",
      "Enter column (1-3): 1\n",
      "2|1|1\n",
      "-----\n",
      "1|2|2\n",
      "-----\n",
      "1|2|1\n",
      "-----\n",
      "Player 2's turn\n",
      "Enter row (1-3): 1\n",
      "Enter column (1-3): 1\n",
      "Cell already occupied. Try again.\n",
      "2|1|1\n",
      "-----\n",
      "1|2|2\n",
      "-----\n",
      "1|2|1\n",
      "-----\n",
      "Player 2's turn\n"
     ]
    }
   ],
   "source": [
    "magic_square = [\n",
    "    [2, 7, 6],\n",
    "    [9, 5, 1],\n",
    "    [4, 3, 8]\n",
    "]\n",
    "def check_win(board, player):\n",
    "    for i in range(3):\n",
    "        if sum(board[i][j] == player for j in range(3)) == 3:\n",
    "            return True\n",
    "        if sum(board[j][i] == player for j in range(3)) == 3:\n",
    "            return True\n",
    "    if sum(board[i][i] == player for i in range(3)) == 3:\n",
    "        return True\n",
    "    if sum(board[i][2 - i] == player for i in range(3)) == 3:\n",
    "        return True\n",
    "    return False\n",
    "def print_board(board):\n",
    "    for row in board:\n",
    "        print(\"|\".join(str(cell) for cell in row))\n",
    "        print(\"-\" * 5)\n",
    "def main():\n",
    "    board = [[0] * 3 for _ in range(3)]\n",
    "    player = 1\n",
    "    while True:\n",
    "        print_board(board)\n",
    "        print(f\"Player {player}'s turn\")\n",
    "        i = int(input(\"Enter row (1-3): \")) - 1\n",
    "        j = int(input(\"Enter column (1-3): \")) - 1\n",
    "        if board[i][j] == 0:\n",
    "            board[i][j] = player\n",
    "            if check_win(board, player):\n",
    "                print(f\"Player {player} wins!\")\n",
    "                break\n",
    "            if player == 1:\n",
    "                player = 2\n",
    "            else:\n",
    "                player = 1\n",
    "        else:\n",
    "            print(\"Cell already occupied. Try again.\")\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "678339e3",
   "metadata": {},
   "source": [
    "## 18.Tic Tac Toe Problem solving by using Adversarial Search approach."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "e95eacec",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Welcome to Tic Tac Toe!\n",
      "Enter a number from 0-8 to make your move.\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "Your turn (X), enter position: 4\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "|   | X |   |\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "AI's turn (O), position: 0\n",
      "-------------\n",
      "| O |   |   |\n",
      "-------------\n",
      "|   | X |   |\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "Your turn (X), enter position: 1\n",
      "-------------\n",
      "| O | X |   |\n",
      "-------------\n",
      "|   | X |   |\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "AI's turn (O), position: 2\n",
      "-------------\n",
      "| O | X | O |\n",
      "-------------\n",
      "|   | X |   |\n",
      "-------------\n",
      "|   |   |   |\n",
      "-------------\n",
      "Your turn (X), enter position: 7\n",
      "-------------\n",
      "| O | X | O |\n",
      "-------------\n",
      "|   | X |   |\n",
      "-------------\n",
      "|   | X |   |\n",
      "-------------\n",
      "Congratulations! You win!\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "class TicTacToe:\n",
    "    def __init__(self):\n",
    "        self.board = [' ' for _ in range(9)]  # Initialize an empty board\n",
    "        self.current_player = 'X'  # 'X' starts first\n",
    "\n",
    "    def display_board(self):\n",
    "        print('-------------')\n",
    "        for i in range(3):\n",
    "            print(f'| {self.board[3*i]} | {self.board[3*i+1]} | {self.board[3*i+2]} |')\n",
    "            print('-------------')\n",
    "\n",
    "    def get_empty_cells(self):\n",
    "        return [i for i, val in enumerate(self.board) if val == ' ']\n",
    "\n",
    "    def is_winner(self, player):\n",
    "        win_positions = [\n",
    "            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n",
    "            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n",
    "            [0, 4, 8], [2, 4, 6]             # Diagonals\n",
    "        ]\n",
    "        for pos in win_positions:\n",
    "            if all(self.board[i] == player for i in pos):\n",
    "                return True\n",
    "        return False\n",
    "\n",
    "    def is_board_full(self):\n",
    "        return all(val != ' ' for val in self.board)\n",
    "\n",
    "    def make_move(self, index, player):\n",
    "        self.board[index] = player\n",
    "\n",
    "    def minimax(self, depth, is_maximizer):\n",
    "        if self.is_winner('X'):\n",
    "            return 1\n",
    "        if self.is_winner('O'):\n",
    "            return -1\n",
    "        if self.is_board_full():\n",
    "            return 0\n",
    "\n",
    "        if is_maximizer:\n",
    "            max_eval = -math.inf\n",
    "            for cell in self.get_empty_cells():\n",
    "                self.make_move(cell, 'X')\n",
    "                eval = self.minimax(depth + 1, False)\n",
    "                self.make_move(cell, ' ')\n",
    "                max_eval = max(max_eval, eval)\n",
    "            return max_eval\n",
    "        else:\n",
    "            min_eval = math.inf\n",
    "            for cell in self.get_empty_cells():\n",
    "                self.make_move(cell, 'O')\n",
    "                eval = self.minimax(depth + 1, True)\n",
    "                self.make_move(cell, ' ')\n",
    "                min_eval = min(min_eval, eval)\n",
    "            return min_eval\n",
    "\n",
    "    def get_best_move(self):\n",
    "        best_move = -1\n",
    "        best_eval = -math.inf\n",
    "        for cell in self.get_empty_cells():\n",
    "            self.make_move(cell, 'X')\n",
    "            eval = self.minimax(0, False)\n",
    "            self.make_move(cell, ' ')\n",
    "            if eval > best_eval:\n",
    "                best_eval = eval\n",
    "                best_move = cell\n",
    "        return best_move\n",
    "\n",
    "    def play_game(self):\n",
    "        print(\"Welcome to Tic Tac Toe!\")\n",
    "        print(\"Enter a number from 0-8 to make your move.\")\n",
    "\n",
    "        while True:\n",
    "            self.display_board()\n",
    "\n",
    "            if self.current_player == 'X':  # Human player's turn\n",
    "                while True:\n",
    "                    try:\n",
    "                        user_move = int(input(\"Your turn (X), enter position: \"))\n",
    "                        if user_move not in self.get_empty_cells():\n",
    "                            print(\"Invalid move. Try again.\")\n",
    "                        else:\n",
    "                            self.make_move(user_move, 'X')\n",
    "                            break\n",
    "                    except ValueError:\n",
    "                        print(\"Invalid input. Please enter a number from 0-8.\")\n",
    "            else:  # AI player's turn\n",
    "                ai_move = self.get_best_move()\n",
    "                print(f\"AI's turn (O), position: {ai_move}\")\n",
    "                self.make_move(ai_move, 'O')\n",
    "\n",
    "            # Check game status\n",
    "            if self.is_winner('X'):\n",
    "                self.display_board()\n",
    "                print(\"Congratulations! You win!\")\n",
    "                break\n",
    "            elif self.is_winner('O'):\n",
    "                self.display_board()\n",
    "                print(\"AI wins. Better luck next time!\")\n",
    "                break\n",
    "            elif self.is_board_full():\n",
    "                self.display_board()\n",
    "                print(\"It's a tie!\")\n",
    "                break\n",
    "\n",
    "            # Switch turns\n",
    "            self.current_player = 'O' if self.current_player == 'X' else 'X'\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    game = TicTacToe()\n",
    "    game.play_game()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
